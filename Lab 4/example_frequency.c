// FreqF38x.c: Measure the frequency of a signal on pin T0.
//
// By:  Jesus Calvino-Fraga (c) 2008-2014
//
// The next line clears the "C51 command line options:" field when compiling with CrossIDE
//  ~C51~

#include <C8051f38x.h>
#include <stdio.h>

#define SYSCLK      48000000L  // SYSCLK frequency in Hz
#define BAUDRATE      115200L  // Baud rate of UART in bps

unsigned char overflow_count;

void PORT_Init (void) {
	P0MDOUT |= 0x10; // Enable UART TX as push-pull output
	XBR0=0b_0000_0001; // Enable UART on P0.4(TX) and P0.5(RX)
	XBR1=0b_0101_0000; // Enable crossbar.  Enable T0 input.
	XBR2=0b_0000_0000;
}

void SYSCLK_Init (void) {
	// CLKSEL&=0b_1111_1000; // Not needed because CLKSEL==0 after reset
#if (SYSCLK == 12000000L)
	//CLKSEL|=0b_0000_0000;  // SYSCLK derived from the Internal High-Frequency Oscillator / 4
#elif (SYSCLK == 24000000L)
	CLKSEL|=0b_0000_0010; // SYSCLK derived from the Internal High-Frequency Oscillator / 2.
#elif (SYSCLK == 48000000L)
	CLKSEL|=0b_0000_0011; // SYSCLK derived from the Internal High-Frequency Oscillator / 1.
#else
	#error SYSCLK must be either 12000000L, 24000000L, or 48000000L
#endif
	OSCICN |= 0x03;   // Configure internal oscillator for its maximum frequency
	RSTSRC  = 0x04;   // Enable missing clock detector
}

void UART0_Init (void) {
	SCON0 = 0x10;

#if (SYSCLK/BAUDRATE/2L/256L < 1)
	TH1    = 0x10000-((SYSCLK/BAUDRATE)/2L);
	CKCON &= ~0x0B;                  // T1M = 1; SCA1:0 = xx
	CKCON |= 0x08;
#elif (SYSCLK/BAUDRATE/2L/256L < 4)
	TH1    = 0x10000-(SYSCLK/BAUDRATE/2L/4L);
	CKCON &= ~0x0B; // T1M = 0; SCA1:0 = 01
	CKCON |= 0x01;
#elif (SYSCLK/BAUDRATE/2L/256L < 12)
	TH1    = 0x10000-(SYSCLK/BAUDRATE/2L/12L);
	CKCON &= ~0x0B; // T1M = 0; SCA1:0 = 00
#else
	TH1    = 0x10000-(SYSCLK/BAUDRATE/2/48);
	CKCON &= ~0x0B; // T1M = 0; SCA1:0 = 10
	CKCON |= 0x02;
#endif
	TL1   = TH1;      // Init Timer1
	TMOD &= ~0xf0;  // TMOD: timer 1 in 8-bit autoreload
	TMOD |= 0x20;
	TR1   = 1; // START Timer1
	TI    = 1;  // Indicate TX0 ready
}

// Uses Timer3 to delay <us> micro-seconds.
void Timer3us(unsigned char us) {
	unsigned char i;               // usec counter

	// The input for Timer 3 is selected as SYSCLK by setting T3ML (bit 6) of CKCON:
	CKCON |= 0b_0100_0000;

	TMR3RL = (-(SYSCLK)/1000000L); // Set Timer3 to overflow in 1us.
	TMR3   = TMR3RL;                 // Initialize Timer3 for first overflow

	TMR3CN = 0x04;                 // Sart Timer3 and clear overflow flag
	for (i = 0; i < us; i++) {      // Count <us> overflows
		while (!(TMR3CN & 0x80));  // Wait for overflow
		TMR3CN &= ~(0x80);         // Clear overflow indicator
		// Check overflow of Timer/Counter 0
		if (TF0==1) {
			TF0=0;
			overflow_count++;
		}
	}
	TMR3CN = 0 ;                   // Stop Timer3 and clear overflow flag
}

void waitms (unsigned int ms) {
	unsigned int j;
	for(j = ms; j != 0; j--) {
		Timer3us(249);
		Timer3us(249);
		Timer3us(249);
		Timer3us(250);
	}
}

void TIMER0_Init(void) {
	TMOD &= 0b_1111_0000; // Set the bits of Timer/Counter 0 to zero
	TMOD |= 0b_0000_0101; // Timer/Counter 0 used as a 16-bit counter
	TR0   = 0; // Stop Timer/Counter 0
}

void main (void) {
	unsigned long freq;
	double capacitance;

	PCA0MD &= ~0x40; // WDTE = 0 (clear watchdog timer enable)
	PORT_Init();     // Initialize Port I/O
	SYSCLK_Init ();  // Initialize Oscillator
	UART0_Init();    // Initialize UART0
	TIMER0_Init();

	// printf("\x1b[2J"); // Clear screen using ANSI escape sequence.
	//
	// printf ("Frequency measurement using Timer/Counter 0.\n"
	//         "File: %s\n"
	//         "Compiled: %s, %s\n\n",
	//         __FILE__, __DATE__, __TIME__);

	while(1) {
		TL0=0;
		TH0=0;
		overflow_count=0;
		TF0=0;
		TR0=1; // Start Timer/Counter 0
		waitms(1000);
		printf("%d\t", overflow_count);
		TR0=0; // Stop Timer/Counter 0
		freq=overflow_count*0x10000L+TH0*0x100L+TL0;

		printf("f=%luHz\t", freq);
		// printf("\x1b[0K"); // ANSI: Clear from cursor to end of line.
		// compute frequency
        // freq = overflow_count * 0x10000L + TH0 * 0x1000L + TL0;

        // compute capacitance
        capacitance = 295.3200 / freq;
		// printf("%lu\t", freq);
        printf("%fuF\n", capacitance);
	}
}
